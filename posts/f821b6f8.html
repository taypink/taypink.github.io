<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OSI&amp;TCP模型 | taypink</title><meta name="author" content="taypink"><meta name="copyright" content="taypink"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="OSI 实际模型和参考模型  传输层Transport 为什么需要传输层？ 服务器同时运行多个应用程序，并持续接收数据包。所有数据包都具有相同的 MAC（第二层）和 IP（第三层）报头。由于这个原因，服务器无法仅通过读取第二层和第三层信息来确定每个数据包的数据应该由哪个应用程序接收。这就是传输层报头信息发挥作用的地方。  TCP  UDP  QinQ  基于802.1">
<meta property="og:type" content="article">
<meta property="og:title" content="OSI&amp;TCP模型">
<meta property="og:url" content="https://taypink.github.io/posts/f821b6f8.html">
<meta property="og:site_name" content="taypink">
<meta property="og:description" content="OSI 实际模型和参考模型  传输层Transport 为什么需要传输层？ 服务器同时运行多个应用程序，并持续接收数据包。所有数据包都具有相同的 MAC（第二层）和 IP（第三层）报头。由于这个原因，服务器无法仅通过读取第二层和第三层信息来确定每个数据包的数据应该由哪个应用程序接收。这就是传输层报头信息发挥作用的地方。  TCP  UDP  QinQ  基于802.1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/98171449?v=4">
<meta property="article:published_time" content="2025-09-19T14:56:57.000Z">
<meta property="article:modified_time" content="2025-10-25T10:55:13.829Z">
<meta property="article:author" content="taypink">
<meta property="article:tag" content="taypink">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/98171449?v=4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://taypink.github.io/posts/f821b6f8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离这篇文章发布有","messageNext":"天了，请注意文章时效性。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OSI&TCP模型',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-10-25 18:55:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/copyright.css"><link rel="stylesheet" href="/css/fish.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/98171449?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top_cute.png')"><nav id="nav"><span id="blog-info"><a href="/" title="taypink"><span class="site-name">taypink</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OSI&amp;TCP模型<a class="post-edit-link" href="null_posts/网工/OSI&amp;TCP模型.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-19T14:56:57.000Z" title="发表于 2025-09-19 22:56:57">2025-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-25T10:55:13.829Z" title="更新于 2025-10-25 18:55:13">2025-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%B7%A5/">网工</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OSI&amp;TCP模型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="osi">OSI</h3>
<h4 id="实际模型和参考模型">实际模型和参考模型</h4>
<p><img src="https://cdn.networkacademy.io/sites/default/files/2025-07/osi-vs-tcp-ip-models.svg" style="zoom:80%;" /></p>
<h4 id="传输层transport">传输层Transport</h4>
<h5 id="为什么需要传输层">为什么需要传输层？</h5>
<p>服务器同时运行多个应用程序，并持续接收数据包。所有数据包都具有相同的
MAC（第二层）和
IP（第三层）报头。由于这个原因，服务器无法仅通过读取第二层和第三层信息来确定每个数据包的数据应该由哪个应用程序接收。这就是传输层报头信息发挥作用的地方。</p>
<p><img
src="https://cdn.networkacademy.io/sites/default/files/2025-07/multiplexing-based-on-ports.svg" /></p>
<h5 id="tcp">TCP</h5>
<p><img src="https://cdn.networkacademy.io/sites/default/files/2025-07/tcp-layer-4-header.svg"  /></p>
<h5 id="udp">UDP</h5>
<p><img
src="https://cdn.networkacademy.io/sites/default/files/2025-07/udp-layer-4-header.svg" /></p>
<h5 id="qinq">QinQ</h5>
<blockquote>
<p>基于802.1 Q封装的隧道协议；通过在用户私网VLAN tag之外封装公网VLAN
tag，在公网中报文只根据公网VLAN Tag传播；在运营商城域网中常用</p>
</blockquote>
<ul>
<li>用户侧为C-VLAN，运营商侧为S-VLAN，通过配置QinQ终结剥离VLAN Tag</li>
<li>CE设备与用户相连，对用户报文封装第一层<a
target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/VLAN.html">VLAN</a>
Tag，即内层VLAN
Tag；PE设备是CE设备的下游设备，对CE设备转发过来的报文封装第二层VLAN
Tag，即外层VLAN Tag。</li>
</ul>
<h6 id="报文格式">报文格式</h6>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=8e74d511800846f48d3ecb5564cc7cc3" style="zoom:67%;" /></p>
<p>很明显看到多了4B的VLAN Tag，也就是S-VLAN</p>
<h4 id="发展历史学习顺序">发展历史&amp;学习顺序</h4>
<h5 id="链路冗余与环路stp-的出现与发展">1. 链路冗余与环路：STP
的出现与发展</h5>
<h6 id="a-早期以太网与环路问题的萌芽stp-出现之前">a)
早期以太网与环路问题的萌芽（STP 出现之前）</h6>
<p>在以太网发展的早期，网络通常是基于<strong>集线器 (Hub)</strong>
构建的。集线器是一个共享介质，它只是简单地将收到的信号广播给所有其他端口。在这种“总线”或“星型”拓扑中，物理环路本身就不容易形成，因为一旦形成，会造成信号的无限反射，网络会立即崩溃。</p>
<p>随着网络规模的扩大，人们开始追求<strong>更高的可靠性</strong>。为了防止单点故障（例如一根线缆断裂），工程师们自然而然地会想到连接多条线缆，形成<strong>冗余路径</strong>。</p>
<p>然而，当<strong>交换机 (Switch)</strong>
出现并取代集线器后，问题就来了。交换机是智能设备，它根据 MAC
地址转发帧，并隔离冲突域。但是，当你在两台交换机之间连接多条链路，或在多台交换机之间形成一个环状拓扑时，交换机的
MAC 学习机制和广播特性会立即导致致命的<strong>二层环路 (Layer 2
Loop)</strong>：</p>
<ul>
<li></li>
<li><strong>广播风暴：</strong> 广播帧（如 ARP 请求、DHCP
请求）会在环路中被无限复制和转发，迅速消耗所有带宽，导致网络瘫痪。</li>
<li><strong>MAC 地址表不稳定 ：</strong>
交换机从环路的不同路径接收到相同的 MAC 地址，导致 MAC
地址表频繁更新，MAC 地址漂移，数据包无法正确转发。</li>
<li><strong>多帧重复：</strong> 目的主机收到大量重复的数据帧。</li>
</ul>
<p>在 STP
出现之前，唯一的“解决方案”是<strong>手动避免环路</strong>，或者<strong>严格只使用单链路，牺牲冗余性</strong>。这显然是不可接受的。</p>
<h5 id="b-stp-的诞生与演进-802.1d-802.1w-802.1s">b) STP 的诞生与演进
(802.1D, 802.1w, 802.1s)</h5>
<p>为了在提供链路冗余的同时防止二层环路，IEEE 于 1990 年发布了
<strong>STP (Spanning Tree Protocol) 802.1D</strong>。</p>
<ul>
<li></li>
<li><strong>STP
的目标：</strong>在包含冗余链路的二层网络中，<strong>自动检测并逻辑性地阻塞冗余路径</strong>，从而形成一个无环路的逻辑拓扑（即一棵“生成树”）。当主用路径发生故障时，被阻塞的备用路径能够自动激活，恢复网络连通性。</li>
<li><strong>STP 的工作方式：</strong>通过在交换机之间周期性交换
<strong>BPDU (Bridge Protocol Data Unit)</strong> 报文来协商。选举
<strong>根桥 (Root Bridge)</strong> 作为逻辑中心。每个非根桥选举一个
<strong>根端口 (Root Port)</strong>（离根桥最近）。每个网段选举一个
<strong>指定端口 (Designated
Port)</strong>（负责该网段到根桥的转发）。<strong>未被选举为根端口或指定端口的端口，就会被置于阻塞
(Blocking) 状态。</strong> 阻塞状态的端口不转发普通数据流量，只接收
BPDU。</li>
<li><strong>STP 的缺点（802.1D）：收敛速度慢：</strong>
从链路故障到备用链路激活，可能需要 30-50 秒（Listen -&gt; Learn -&gt;
Forwarding 状态转换），在生产环境中这太长了。<strong>低效：</strong>
在任何给定的时间点，冗余链路中的一部分是被阻塞的，无法用于数据转发，造成带宽浪费。<strong>单根桥：</strong>
整个二层域只有一个根桥，容易成为瓶颈。<strong>单路径：</strong> 同一个
VLAN 内的所有流量都必须经过根桥转发，无法实现负载分担。</li>
<li><strong>STP 的演进：RSTP (Rapid Spanning Tree Protocol,
802.1w)：出现时间：</strong> 2001 年。<strong>改进：</strong>
大幅加快了收敛速度（通常在几百毫秒内），通过点对点链路检测、边缘端口等机制。<strong>局限：</strong>
仍然是每个 VLAN 只能有一棵生成树，无法实现 VLAN
间的负载分担，效率仍然不高。<strong>MSTP (Multiple Spanning Tree
Protocol, 802.1s)：出现时间：</strong> 2002 年。<strong>改进：</strong>
允许将多个 VLAN 映射到不同的<strong>多生成树实例 (Multiple Spanning Tree
Instance, MSTI)</strong>。这样，不同的 VLAN
组可以走不同的逻辑路径，从而在一定程度上实现<strong>基于 VLAN
的负载分担</strong>，提高了链路利用率。<strong>局限：</strong>
核心仍然是“阻塞”冗余链路，只是阻塞得更智能、更细粒度。部分链路依然无法同时用于转发所有流量。</li>
</ul>
<h6 id="c-stp-之后的发展走向主动-主动冗余和无环架构">c) STP
之后的发展：走向主动-主动冗余和无环架构</h6>
<p>为了克服 STP
的根本性缺陷（阻塞链路造成的带宽浪费），网络技术开始向<strong>主动-主动
(Active-Active)</strong> 冗余和<strong>无环架构</strong>发展：</p>
<ol type="1">
<li></li>
<li><strong>链路聚合 (Link Aggregation, LAG / Eth-Trunk / Port-channel,
802.3ad / 802.1AX)：出现时间：</strong> 早期非标准实现，后标准化于 2000
年。<strong>理念：</strong>
将多条物理以太网链路捆绑成<strong>一条逻辑链路</strong>。<strong>解决了什么：</strong>
对 STP
而言，它只看到一条逻辑链路，因此不会再阻塞内部的物理成员链路。这实现了<strong>单设备之间的链路主动-主动负载分担和冗余。局限：</strong>
只能解决两台直连设备之间的冗余。如果连接多台交换机，或者设备自身故障，LAG
无法提供设备级冗余。STP 仍然需要在整个网络中运行，以防 Eth-Trunk
外部的环路。</li>
<li><strong>多机箱链路聚合 (MC-LAG / MLAG)：出现时间：</strong> 各厂商在
2000 年代中期开始推出。<strong>理念：</strong>
将一台设备（如服务器或接入交换机）的 LAG
同时连接到<strong>两台独立的物理交换机</strong>上，但这两台交换机协同工作，对下层设备表现为<strong>单一的逻辑
LAG 对端</strong>。<strong>解决了什么：</strong>
提供了<strong>设备级别的主动-主动冗余</strong>。即使其中一台汇聚交换机故障，流量仍能通过另一台正常工作的交换机转发，且所有链路都可用于负载分担。彻底消除了连接到
MC-LAG 的设备对 STP 的需求。<strong>应用：</strong>
数据中心、大型企业网络中实现高可用性的主流技术。</li>
<li><strong>交换机堆叠 (Stacking) / 虚拟化技术 (Virtual Chassis / VSS /
CSS)：出现时间：</strong>
堆叠技术很早就有了，虚拟化技术是近十年的发展。<strong>理念：</strong>
将多台物理交换机通过专有线缆或技术连接，使其在<strong>逻辑上成为一台单一的交换机</strong>。<strong>解决了什么：</strong>
简化管理、提高密度、提供设备级冗余。结合 LAG
使用，可以实现跨堆叠成员的端口聚合，提供设备和链路双重冗余。<strong>与
MC-LAG 区别：</strong> 堆叠是真正的“一台”逻辑设备，共享控制平面。MC-LAG
中的每台交换机仍有独立控制平面，通过特定协议同步状态。</li>
<li><strong>无环路网络架构 (Layer 3 Fabric / Clos
架构，VXLAN/EVPN)：出现时间：</strong> 2010
年代以来，随着数据中心和云网络的发展。<strong>理念：</strong>
在数据中心等高性能网络中，完全<strong>消除二层环路的概念，转而使用三层路由协议构建网络。技术：</strong>
基于 <strong>Leaf-Spine (胖树) 架构</strong>，通过所有链路都运行路由协议
(如 OSPF, BGP) 实现等价多路径转发 (ECMP)。<strong>VXLAN (Virtual
eXtensible LAN) / EVPN (Ethernet VPN)：</strong>
在这种三层路由架构之上，通过 VXLAN
等叠加网络技术来构建虚拟的二层网络，实现虚拟机的跨区域迁移。EVPN
作为控制平面，通过 BGP 路由协议来通告 MAC 地址和 IP
地址信息，从而实现无环路的二层域扩展。<strong>解决了什么：</strong>
彻底废弃了
STP，所有链路都可以主动转发流量，实现了最高效的带宽利用率、最短的收敛时间，并且易于扩展。这是当前数据中心网络的主流趋势。</li>
</ol>
<hr />
<h5 id="网络技术学习路线建议以-netdevops-工程师为目标">3.
网络技术学习路线建议（以 NetDevOps 工程师为目标）</h5>
<p>作为一名深耕 NetDevOps
的工程师，我强烈推荐一个从基础到前沿、理论与实践结合的学习路线。这个路线不仅要掌握网络技术，更要融入自动化思维和技能。</p>
<p><strong>阶段一：网络基础与核心技能 (夯实基础)</strong></p>
<ol type="1">
<li></li>
<li><strong>操作系统基础：Linux
命令与概念</strong>文件系统、进程管理、网络配置（IP, Route, Netstat, SS
等）SSH, SCP, RsyncBash Shell 脚本基础<strong>NetDevOps 意义：</strong>
几乎所有自动化工具都运行在 Linux 上，且网络设备本身也多是类 Unix
系统。</li>
<li><strong>网络理论基础 (OSI &amp; TCP/IP
模型)</strong>各层功能、协议栈、封装与解封装TCP/UDP, IP, ARP,
ICMP端口号、套接字 (Socket)</li>
<li><strong>以太网与 VLAN：</strong>MAC 地址、交换机工作原理 (MAC
学习、转发、泛洪)VLAN (802.1Q)、Trunk (Access/Trunk/Hybrid
模式)<strong>STP (802.1D, RSTP,
MSTP)</strong>：理解其原理、配置和收敛过程，知道它的优缺点及为何被淘汰。链路聚合
(LAG / Eth-Trunk / Port-channel)。</li>
<li><strong>IP 路由基础 (IPv4 &amp; IPv6)</strong>IP 地址、子网划分
(CIDR)、VLSM静态路由、默认路由路由表解读、路由转发原理IPv6
地址类型、自动配置 (SLAAC)、NDP 协议。</li>
<li><strong>常用网络服务：</strong>DNS (域名解析)DHCP (IP
地址动态分配)NTP (时间同步)Ping, Traceroute 等诊断工具。</li>
<li><strong>基础网络设备操作：</strong>交换机、路由器的基本配置与管理
(CLI 操作)。不同厂商 (如华为、思科) 命令行的对比。<strong>NetDevOps
意义：</strong> 这是你自动化操作的对象。</li>
</ol>
<p><strong>阶段二：进阶网络技术与解决方案 (拓宽视野)</strong></p>
<ol type="1">
<li></li>
<li><strong>高级路由协议：IGP (内部网关协议)：</strong> OSPF、IS-IS
(企业和运营商常用)、EIGRP
(思科私有)。理解其工作原理、收敛、区域划分等。<strong>EGP
(外部网关协议)：</strong> BGP
(运营商和数据中心互联核心)。理解其路径属性、选路原则、路由策略。</li>
<li><strong>网络冗余与高可用性：</strong>VRRP/HSRP
(网关冗余协议)<strong>MC-LAG / MLAG
(多机箱链路聚合)</strong>：理解其原理、配置和应用场景，这是取代 STP
阻塞链路的关键技术之一。<strong>SD-WAN (Software-Defined Wide Area
Network)：</strong>
理解其架构、优势、控制器、Overlay/Underlay、流量优化等。</li>
<li><strong>运营商网络技术 (如果你对运营商方向感兴趣)：MPLS
(Multi-Protocol Label Switching)：</strong> LDP, RSVP-TE, L3VPN, L2VPN
(VPLS, VPWS)。这是运营商网络的核心。<strong>NFV (Network Function
Virtualization)：</strong> VNF, NFVI, MANO
概念。<strong>传输网络：</strong> PTN, SPN, OTN 的基本概念和作用。</li>
<li><strong>数据中心网络：Leaf-Spine 架构：</strong>
理解其设计理念和优势。<strong>VXLAN (Virtual Extensible LAN) / EVPN
(Ethernet VPN)：</strong> 理解叠加网络、Underlay/Overlay
关系，这是现代数据中心无环架构的核心。负载均衡 (Load
Balancing)：L4/L7。</li>
<li><strong>网络安全：</strong>ACL (Access Control List)NAT
(网络地址转换)防火墙 (Stateful Firewall, Zone-Based Firewall)VPN (IPsec
VPN, SSL VPN)DDoS 防护、IDS/IPS (入侵检测/防御系统)。AAA
(认证、授权、计费)。<strong>NetDevOps 意义：</strong>
安全策略的自动化部署和审计。</li>
<li><strong>QoS (Quality of
Service)：</strong>流量分类、标记、限速、整形、拥塞管理
(队列)。<strong>NetDevOps 意义：</strong> 自动化 QoS
策略的下发与调整。</li>
</ol>
<p><strong>阶段三：网络自动化与 NetDevOps 实践 (成为专家)</strong></p>
<ol type="1">
<li></li>
<li><strong>编程基础：Python</strong>数据结构、函数、模块、错误处理。文件操作、JSON/YAML/XML
数据格式。<strong>NetDevOps 意义：</strong> Python
是网络自动化的首选语言。</li>
<li><strong>版本控制：Git</strong>基础操作 (clone, commit, push, pull,
branch, merge)GitHub/GitLab 使用。<strong>NetDevOps 意义：</strong>
网络配置代码化、变更追踪、协作开发。</li>
<li><strong>网络自动化工具与库：Netmiko / Paramiko：</strong> 基于 SSH
的 CLI 自动化 (命令发送、结果解析)。<strong>NAPALM：</strong>
跨厂商的网络设备抽象层，统一 API 操作。<strong>Requests
(Python)：</strong> 用于与 RESTful API 交互。<strong>Ansible：</strong>
强大的配置管理和自动化工具 (Playbook 编写、模块使用、Jinja2
模板)。<strong>NetDevOps 意义：</strong>
实现配置部署、状态获取、自动化变更等。</li>
<li><strong>网络设备 API 与协议：NETCONF / RESTCONF：</strong> 基于
XML/JSON 的结构化配置和数据获取协议。<strong>gRPC / gNMI (Google Network
Management Interface)：</strong>
面向未来的高速、流式遥测和配置协议。<strong>NetDevOps 意义：</strong> 从
CLI 向 API 驱动转变，实现更高效、更可靠的自动化。</li>
<li><strong>基础设施即代码 (IaC)：Terraform (或其他类似工具)：</strong>
用于网络资源的声明式部署和管理 (如云网络、SD-WAN)。<strong>NetDevOps
意义：</strong> 实现网络架构的蓝图管理和自动化部署。</li>
<li><strong>持续集成/持续交付 (CI/CD) 概念：</strong>理解 CI/CD
流程、Jenkins/GitLab CI 等工具。<strong>NetDevOps 意义：</strong>
将网络变更纳入自动化流水线，实现测试、部署和回滚的自动化。</li>
<li><strong>网络监控与遥测：</strong>SNMP, Syslog。<strong>Streaming
Telemetry (流式遥测)：</strong> 高粒度、实时的数据采集。数据可视化工具
(Grafana)、日志分析 (ELK Stack)。<strong>NetDevOps 意义：</strong>
自动化监控、故障预警、性能分析。</li>
<li><strong>云网络基础 (AWS/Azure/GCP)：</strong>VPC, Subnets, Security
Groups, NACLs, Direct Connect/ExpressRoute。<strong>NetDevOps
意义：</strong> 云资源的 IaC 管理。</li>
</ol>
<ul>
<li></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://taypink.github.io">taypink</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://taypink.github.io/posts/f821b6f8.html">https://taypink.github.io/posts/f821b6f8.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taypink.github.io" target="_blank">taypink</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/98171449?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">taypink</div><div class="author-info__description">懒得写描述</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/taypink" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#osi"><span class="toc-number">1.</span> <span class="toc-text">OSI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">实际模型和参考模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82transport"><span class="toc-number">1.2.</span> <span class="toc-text">传输层Transport</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么需要传输层？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp"><span class="toc-number">1.2.2.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#udp"><span class="toc-number">1.2.3.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#qinq"><span class="toc-number">1.2.4.</span> <span class="toc-text">QinQ</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">报文格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">发展历史&amp;学习顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%86%97%E4%BD%99%E4%B8%8E%E7%8E%AF%E8%B7%AFstp-%E7%9A%84%E5%87%BA%E7%8E%B0%E4%B8%8E%E5%8F%91%E5%B1%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 链路冗余与环路：STP
的出现与发展</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E6%97%A9%E6%9C%9F%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%8E%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98%E7%9A%84%E8%90%8C%E8%8A%BDstp-%E5%87%BA%E7%8E%B0%E4%B9%8B%E5%89%8D"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">a)
早期以太网与环路问题的萌芽（STP 出现之前）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-stp-%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%BC%94%E8%BF%9B-802.1d-802.1w-802.1s"><span class="toc-number">1.3.2.</span> <span class="toc-text">b) STP 的诞生与演进
(802.1D, 802.1w, 802.1s)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#c-stp-%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%91%E5%B1%95%E8%B5%B0%E5%90%91%E4%B8%BB%E5%8A%A8-%E4%B8%BB%E5%8A%A8%E5%86%97%E4%BD%99%E5%92%8C%E6%97%A0%E7%8E%AF%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">c) STP
之后的发展：走向主动-主动冗余和无环架构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%BB%BA%E8%AE%AE%E4%BB%A5-netdevops-%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B8%BA%E7%9B%AE%E6%A0%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.
网络技术学习路线建议（以 NetDevOps 工程师为目标）</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By taypink</div><div class="footer_custom_text">别翻了，到底啦！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script async src="/js/title.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>